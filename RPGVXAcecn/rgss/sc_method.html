<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML lang=zh><HEAD><TITLE>Method</TITLE>
<META content="text/html; charset=GBK" http-equiv=Content-Type>
<META content=text/css http-equiv=Content-Style-Type><LINK rel=stylesheet 
type=text/css href="../style.css">
<META name=GENERATOR content="MSHTML 9.00.8112.16447"></HEAD>
<BODY>
<H1>Method</H1>
<P>被 <A 
href="rgss/sc_object.html#method">Object#method</A>&nbsp;封装进对象之中的方法所组成的类。这个方法本身（注意不是方法的名称）和其被接受的对象被双双封装起来。和&nbsp;<A 
href="rgss/sc_proc.html">Proc</A> 不同，Proc的运行环境是不会被保存的。</P>
<P>不同于&nbsp;<A href="sc_proc.html">Proc</A>:&nbsp;Method 只可以在取得另外一个方法的时候被创建，但是 
Proc 可以在任何情况下被创建。有鉴于此，Proc 更适合单独使用，而 Method 适合重复使用。</P><PRE>class Foo
  def foo(arg)
    "foo called with arg #{arg}"
  end
end
 
m = Foo.new.method(:foo)
 
p m             # =&gt; #&lt;Method: Foo#foo&gt;
p m.call(1)     # =&gt; "foo called with arg 1"
</PRE>
<H2>超类</H2>
<UL>
  <LI><A href="sc_object.html">Object</A> </LI></UL>
<H2>方法</H2>
<DL>
  <DT><A name=call></A>call(<VAR>arg</VAR> ... ) 
  <DT><A name=call_2></A>call(<VAR>arg</VAR> ... ) { ... } 
  
  <DD>
  <P>启动一个封装于对象之中的方法，参数和区块都不做改动的传递到函数之中。</P></DD></DL>
<H6></H6></BODY></HTML>
