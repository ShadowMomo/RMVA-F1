<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML lang=zh><HEAD><TITLE>Method</TITLE>
<META content="text/html; charset=GBK" http-equiv=Content-Type>
<META content=text/css http-equiv=Content-Style-Type><LINK rel=stylesheet 
type=text/css href="../style.css">
<META name=GENERATOR content="MSHTML 9.00.8112.16447"></HEAD>
<BODY>
<H1></H1>
<P><A 
href="rgss/sc_object.html#method"><FONT 
face=微软雅黑>Object#method</FONT></A><FONT 
face=微软雅黑>&nbsp;封装进对象之中的方法所组成的类。这个方法本身（注意不是方法的名称）和其被接受的对象被双双封装起来。和&nbsp;</FONT><A 
href="rgss/sc_proc.html"><FONT 
face=微软雅黑>Proc</FONT></A></P>
<P><A href="sc_proc.html"><FONT 
face=微软雅黑>Proc</FONT></A><FONT face=微软雅黑>:&nbsp;Method 只可以在取得另外一个方法的时候被创建，但是 
Proc 可以在任何情况下被创建。有鉴于此，Proc 更适合单独使用，而 Method 适合重复使用。</FONT></P><PRE><FONT face=微软雅黑>class Foo
  def foo(arg)
    "foo called with arg #{arg}"
  end
end
 
m = Foo.new.method(:foo)
 
p m             # =&gt; #&lt;Method: Foo#foo&gt;
p m.call(1)     # =&gt; "foo called with arg 1"
</FONT></PRE>
<H2></H2>
<UL>
  <LI><A href="sc_object.html"></A><FONT 
  face=微软雅黑> </FONT></LI></UL>
<H2></H2>
<DL>
  <DT><A name=call></A>
  <DT><A name=call_2></A><FONT face=微软雅黑>call(<VAR>arg</VAR> ... ) { ... } 
  </FONT>
  <DD>
  <P></P></DD></DL>
<H6></H6></BODY></HTML>
