<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML lang=zh><HEAD><TITLE>Method</TITLE>
<META content="text/html; charset=GBK" http-equiv=Content-Type>
<META content=text/css http-equiv=Content-Style-Type><LINK rel=stylesheet
type=text/css href="../style.css">
<META name=GENERATOR content="MSHTML 9.00.8112.16447"></HEAD>
<BODY>
<H1>Method</H1>
<P>被 <A
href="rgss/sc_object.html#method">Object#method</A> 封装进对象之中的方法所组成的类。这个方法本身的内容（注意不是名称）和其被接受的对象被封装到对象中。和 <A
href="rgss/sc_proc.html">Proc</A> 不同，生成对象时的上下文是不会被保存的。</P>
<P>不同于 <A href="sc_proc.html">Proc</A>: Method 必须要对应方法存在时才能创建，而 Proc 无需准备即可创建。有鉴于此，Proc 更适合一次性使用，而 Method 适合重复使用。此外，根据内含的代码量来看，Proc 适合小规模代码，而 Method 适合大规模代码。</P><PRE>class Foo
  def foo(arg)
    "foo called with arg #{arg}"
  end
end

m = Foo.new.method(:foo)

p m             # =&gt; #&lt;Method: Foo#foo&gt;
p m.call(1)     # =&gt; "foo called with arg 1"
</PRE>
<H2>超类</H2>
<UL>
  <LI><A href="sc_object.html">Object</A> </LI></UL>
<H2>方法</H2>
<DL>
  <DT><A name=call></A>call(<VAR>arg</VAR> ... )
  <DT><A name=call_2></A>call(<VAR>arg</VAR> ... ) { ... }

  <DD>
  <P>启动封装于对象之中的方法，参数和区块都原封不动地传递给方法。。</P></DD></DL>
<H6></H6></BODY></HTML>
